<?php

namespace NxSys\Applications\Atlas\Services;

use NxSys\Applications\Atlas\Services\XMapUtil\XMapNode;

use Silex\Application as WebApp;

class XMap
{
	/**
	 * Generates a tree map node data list containing entries from two rev/path pairs.
	 * @param Int $iBuffer 0 or 1: Determines which slot should be used for the "current" state information. After retrieving the new node data, pass the opposite value to jsTreeMap's sizeOption value.
	 * @param String $sCurrentRev The revision of the "current" state.
	 * @param String $sCurrentPath The path of the "current" state.
	 * @param String $sNextRev The revision of the "next" state.
	 * @param String $sNextPath The path of the "next" state.
	 * @param Int $iMaxRelativeDepth The maximum depth to display, relative to the "next" path's depth.
	 * @return Array Node data to pass to jsTreeMap.
	 */
	public function generateNewXMap($iBuffer, $sCurrentRev, $aCurrentPath, $sNextRev, $aNextPath, $iMaxRelativeDepth = 3)
	{
		//Get current Map, top level bound by max relative depth.
		$oMap1 = $this->testMap1();
		//Get next map
		$oMap2 = $this->testMap2();
		
		//Determine which to parse first
		if ($iBuffer == 0)
		{
			$oCurrentMap = $oMap1;
			$oNextMap = $oMap2;
		}
		else
		{
			$oCurrentMap = $oMap2;
			$oNextMap = $oMap1;
		}
		
		$iMaxAbsoluteDepth = count($aNextPath) + $iMaxRelativeDepth;
		
		//Build map transition from First -> Second
		$aXMap = ["id" => "root",
				  "children" => $this->recursiveMap($oCurrentMap, $oNextMap, $iMaxAbsoluteDepth)];
		
		//Add any nodes (bound by depth scoping) created in Second map.
		//Modifies $aXMap by reference.
		$this->recursiveAdd($oNextMap, $oCurrentMap, $aXMap, $iMaxAbsoluteDepth);
		
		//Iterate over nodes to turn absolute size values to percentage values.
		var_dump($aXMap);
	}
	
	/**
	 * Recursively iterate over a node map, building the required XMap object.
	 * Will handle changes and removals.
	 * Will NOT handle additions, needs additional processing to go over new map to find nodes not in current map.
	 * @param XMapNode $oCurrentNode Current XMapNode
	 * @param XMapNode $oNewMap Root node of map to update to.
	 * @param Int $iMaxAbsoluteDepth Maximum recursion depth
	 * @return Array Tree Map Node Data
	 */
	private function recursiveMap($oCurrentNode, $oNewMap, $iMaxAbsoluteDepth)
	{
		$iCurrentDepth = count($oCurrentNode->path);
		
		$aNodeChildren = [];
		
		//Iterate over current children
		foreach ($oCurrentNode->children as $oChild)
		{
			//Get current size.
			if ($iCurrentDepth + 1 > $iMaxAbsoluteDepth)
			{
				//Child is greater than max depth, get recursive size.
				$iSize = [$this->recursiveSize($oChild)];
			}
			else
			{
				$iSize = [$oChild->size];
			}
			
			//Get updated size.
			try
			{
				//Find the corresponding node in the new map.
				$oMatchingNode = $oNewMap->locate($oChild->path);
				if ($iCurrentDepth + 1 > $iMaxAbsoluteDepth)
				{
					//Child is greater than max depth, get recursive size.
					$iSize[] = $this->recursiveSize($oMatchingNode);
				}
				else
				{
					$iSize[] = $oMatchingNode->size;
				}
			}
			catch (\OutOfRangeException $e)
			{
				//Path not found in new map. Path was therefore removed, setting size to 0.
				$iSize[] = 0;
			}
			
			//Form array for child.
			$aCurrentChild = ["id" => join('/', $oChild->path),
							  "color" => [0.5],
							  "size" => $iSize];
			
			if ($iCurrentDepth + 1 <= $iMaxAbsoluteDepth and count($oChild->children) > 0)
			{
				//Not yet at maximum depth, and child has more children. Recurse over them.
				$aCurrentChild["children"] = $this->recursiveMap($oChild, $oNewMap, $iMaxAbsoluteDepth);
			}
			
			//Add child to list.
			$aNodeChildren[] = $aCurrentChild;
		}
		
		return $aNodeChildren;
	}
	
	/**
	 * Simple function to recursively sum sizes.
	 * @param XMapNode $oCurrentNode Node to get size for.
	 * @return int Size of Node and all children nodes, recursively.
	 */
	private function recursiveSize($oCurrentNode)
	{
		$oSize = $oCurrentNode->size;
		
		foreach ($oCurrentNode->children as $oChild)
		{
			$oSize += $this->recursiveSize($oChild);
		}
		
		return $oSize;
	}
	
	/**
	 * Recursively iterate over an XMap, adding any new nodes found in the updated map.
	 * Modifies XMap by reference.
	 * @param XMapNode $oCurrentNode The new map to search for additions.
	 * @param XMapNode $oOldMap The original map to check against.
	 * @param Array $aXMap Current Node Data as generated by recursiveMap(), modified by reference.
	 * @param Int $iMaxAbsoluteDepth Maximum depth.
	 */
	private function recursiveAdd($oCurrentNode, $oOldMap, &$aXMap, $iMaxAbsoluteDepth)
	{
		$iCurrentDepth = count($oCurrentNode->path);
		
		foreach ($oCurrentNode->children as $oChild)
		{
			try
			{
				$oOldMap->locate($oChild->path);
				//$oChild exists in old map, continue recursion.
				$this->recursiveAdd($oChild, $oOldMap, $aXMap, $iMaxAbsoluteDepth);
			}
			catch (\OutOfRangeException $e)
			{
				//$oChild does not exist in old map, create and add to node data.
				if ($iCurrentDepth + 1 > $iMaxAbsoluteDepth)
				{
					$iSize = $this->recursiveSize($oChild);
				}
				else
				{
					$iSize = $oChild->size;
				}
				
				$aCurrentChild = ["id" => join('/', $oChild->path),
									"color" => [0.5],
									"size" => [0, $iSize]];
				
				if ($iCurrentDepth + 1 <= $iMaxAbsoluteDepth and count($oChild->children) > 0)
				{
					$aCurrentChild["children"] = $this->recursiveMap($oChild, $oNewMap, $iMaxAbsoluteDepth);
				}
				
				//Add the new child to the node data.
				$this->addToXMap($aXMap, $oChild->path, $aCurrentChild);
			}
		}
	}

	/**
	 * Adds a node to the xmap at the given path.
	 * @param Array $aXMapRoot Node data, modified by reference.
	 * @param Array $aPath Path array.
	 * @param Array $aNode Node to add.
	 */
	private function addToXMap(&$aXMapRoot, $aPath, $aNode)
	{
		//Get list of steps needed to reach the given path.
		$aIndexPath = $this->findXMapPath($aXMapRoot, $aPath);
		
		$aTruePath = [];
		
		//Since each node also needs a "children" key, add it before the next index piece.
		foreach ($aIndexPath as $iPiece)
		{
			$aTruePath[] = "children";
			$aTruePath[] = $iPiece;
		}
		
		//Add a final "children" to path, so we're adding to the children of the end node.
		$aTruePath[] = "children";
		
		//Count existing children to determine new index.
		$iNewIndex = $this->getChildCount($aXMapRoot, $aTruePath);
		$aTruePath[] = $iNewIndex;
		
		//Generate the new array using the built path.
		$aReplacementArray = $this->buildReplacementArray($aNode, $aTruePath);
		
		//Use built-in array_replace_recursive to modify $aXMapRoot
		$aXMapRoot = array_replace_recursive($aXMapRoot, $aReplacementArray);
	}
	
	private function buildReplacementArray($aNewNode, $remainingPath)
	{
		$arr = [];
		if (count($remainingPath) > 0)
		{
			$curPiece = $remainingPath[0];
			$remainingPath = array_slice($remainingPath, 1);
			$arr[$curPiece] = $this->buildReplacementArray($aNewNode, $remainingPath);
			return $arr;
		}
		else
		{
			return $aNewNode;
		}
	}
	
	private function getChildCount($aXMap, $aIndices)
	{
		$aCurNode =  $aXMap;
		
		foreach ($aIndices as $mIndex)
		{
			$aCurNode = $aCurNode[$mIndex];
		}
		
		return count($aCurNode);
	}
	
	/*
	 * Recursively walks an XMap to find the steps required to reach a given path.
	 * @param Array $aXMap Node data.
	 * @param Array $aPath Path to find.
	 * @param Array $aIndices Index list so far.
	 * @param int $iCurrentDepth Current recursion depth.
	 * @return Array Index steps to the given path.
	 */
	private function findXMapPath($aXMap, $aPath, $aIndices = [], $iCurrentDepth = 1)
	{
		if (!array_key_exists("children", $aXMap))
		{
			return $aIndices;
		}
		$sNextID = join("/", array_slice($aPath, 0, $iCurrentDepth + 1));
		foreach ($aXMap["children"] as $iKey=>$aChild)
		{
			if ($aChild["id"] == $sNextID)
			{
				$aIndices[] = $iKey;
				return $this->findXMapPath($aChild, $aPath, $aIndices, $iCurrentDepth + 1);
			}
		}
		return $aIndices;
	}
	
	private function testMap1()
	{
		$oRoot = new XMapNode(["root"], 1);
		$oFoo = new XMapNode(["root", "foo"], 1, $oRoot);
		new XMapNode(["root", "foo", "file1"], 500, $oFoo);
		new XMapNode(["root", "foo", "file2"], 300, $oFoo);
		$oBar = new XMapNode(["root", "bar"], 1, $oRoot);
		new XMapNode(["root", "bar", "file1"], 750, $oBar);
		new XMapNode(["root", "bar", "file2"], 200, $oBar);
		
		return $oRoot;
	}
	
	private function testMap2()
	{
		$oRoot = new XMapNode(["root"], 1);
		$oFoo = new XMapNode(["root", "foo"], 1, $oRoot);
		new XMapNode(["root", "foo", "file1"], 500, $oFoo);
		new XMapNode(["root", "foo", "file2"], 400, $oFoo);
		$oBar = new XMapNode(["root", "bar"], 1, $oRoot);
		new XMapNode(["root", "bar", "file1"], 700, $oBar);
		new XMapNode(["root", "bar", "file2"], 300, $oBar);
		new XMapNode(["root", "bar", "file3"], 500, $oBar);
		
		return $oRoot;
	}
}